// Copyright Splunk Inc. 2025
// SPDX-License-Identifier: Apache-2.0

package testutils

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"gopkg.in/yaml.v3"
)

// Constants for Splunk components.
const (
	DefaultSourceTypeLabel = "com.splunk.sourcetype"
	DefaultSourceLabel     = "com.splunk.source"
	DefaultIndexLabel      = "com.splunk.index"
	DefaultNameLabel       = "otel.log.name"
)

var configFilePath = "./testdata/test_config.yaml"

type IntegrationTestsConfig struct {
	Host           string `yaml:"HOST"`
	User           string `yaml:"USER"`
	Password       string `yaml:"PASSWORD"`
	UIPort         string `yaml:"UI_PORT"`
	HecPort        string `yaml:"HEC_PORT"`
	ManagementPort string `yaml:"MANAGEMENT_PORT"`
	EventIndex     string `yaml:"EVENT_INDEX"`
	MetricIndex    string `yaml:"METRIC_INDEX"`
	TraceIndex     string `yaml:"TRACE_INDEX"`
	HecToken       string `yaml:"HEC_TOKEN"`
	SplunkImage    string `yaml:"SPLUNK_IMAGE"`
}

func GetConfigVariable(key string) (string, error) {
	// Read YAML file
	fileData, err := os.ReadFile(configFilePath)
	if err != nil {
		return "", fmt.Errorf("Error reading file: %v", err)
	}

	var config IntegrationTestsConfig
	err = yaml.Unmarshal(fileData, &config)
	if err != nil {
		return "", fmt.Errorf("Error decoding YAML: %v", err)
	}

	switch key {
	case "HOST":
		return config.Host, nil
	case "USER":
		return config.User, nil
	case "PASSWORD":
		return config.Password, nil
	case "UI_PORT":
		return config.UIPort, nil
	case "HEC_PORT":
		return config.HecPort, nil
	case "MANAGEMENT_PORT":
		return config.ManagementPort, nil
	case "EVENT_INDEX":
		return config.EventIndex, nil
	case "METRIC_INDEX":
		return config.MetricIndex, nil
	case "TRACE_INDEX":
		return config.TraceIndex, nil
	case "HEC_TOKEN":
		return config.HecToken, nil
	case "SPLUNK_IMAGE":
		return config.SplunkImage, nil
	default:
		fmt.Println("Invalid field")
		return "None", nil
	}
}

// WriteToStdin pipes the provided content into os.Stdin and returns a restore function.
func WriteToStdin(t *testing.T, content string) func() {
	t.Helper()

	r, w, err := os.Pipe()
	if err != nil {
		t.Fatalf("failed to create stdin pipe: %v", err)
	}

	if _, err = io.Copy(w, strings.NewReader(content)); err != nil {
		t.Fatalf("failed to write stdin content: %v", err)
	}
	if err = w.Close(); err != nil {
		t.Fatalf("failed to close stdin writer: %v", err)
	}

	original := os.Stdin
	os.Stdin = r

	return func() {
		os.Stdin = original
		_ = r.Close()
	}
}

// CaptureStdout captures all stdout output generated by fn and returns it as a string.
func CaptureStdout(t *testing.T, fn func()) string {
	t.Helper()

	original := os.Stdout
	r, w, err := os.Pipe()
	if err != nil {
		t.Fatalf("failed to create stdout pipe: %v", err)
	}
	os.Stdout = w

	outputCh := make(chan string, 1)
	go func() {
		var buf bytes.Buffer
		_, _ = io.Copy(&buf, r)
		_ = r.Close()
		outputCh <- buf.String()
	}()

	fn()

	// TODO: Find a way to synchronize without sleep. This is currently required
	time.Sleep(1 * time.Second)

	_ = w.Close()
	os.Stdout = original

	return <-outputCh
}

// CaptureStdoutLines returns a channel streaming stdout lines and a restore function.
func CaptureStdoutLines(t *testing.T) (<-chan string, func()) {
	t.Helper()

	original := os.Stdout
	r, w, err := os.Pipe()
	if err != nil {
		t.Fatalf("failed to create stdout pipe: %v", err)
	}
	os.Stdout = w

	lines := make(chan string, 50)
	go func() {
		scanner := bufio.NewScanner(r)
		buf := make([]byte, 0, 64*1024)
		scanner.Buffer(buf, 10*1024*1024)
		for scanner.Scan() {
			lines <- scanner.Text()
		}
		close(lines)
		_ = r.Close()
	}()

	return lines, func() {
		os.Stdout = original
		_ = w.Close()
	}
}

// GetFreePort returns an available TCP port bound to the loopback address.
func GetFreePort(t *testing.T) int {
	t.Helper()

	l, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("failed to listen on ephemeral port: %v", err)
	}
	defer l.Close()
	return l.Addr().(*net.TCPAddr).Port
}

// PostOTLP sends the provided payload to the OTLP endpoint, retrying until success or timeout.
func PostOTLP(t *testing.T, port int, path string, body []byte) {
	t.Helper()

	url := fmt.Sprintf("http://127.0.0.1:%d%s", port, path)
	deadline := time.Now().Add(5 * time.Second)

	lastRespCode := 0
	for {
		resp, err := http.Post(url, "application/json", bytes.NewReader(body))
		if err == nil {
			lastRespCode = resp.StatusCode
			_ = resp.Body.Close()
			if resp.StatusCode == http.StatusOK {
				return
			}
		}

		if time.Now().After(deadline) {
			t.Fatalf("failed to POST %s, response code: %v", path, lastRespCode)
		}
		time.Sleep(100 * time.Millisecond)
	}
}

// CollectLines reads expectedCount lines from the provided channel or fails on timeout.
func CollectLines(t *testing.T, ch <-chan string, expectedCount int) []string {
	t.Helper()

	var lines []string
	timeout := time.After(10 * time.Second)
	for len(lines) < expectedCount {
		select {
		case line, ok := <-ch:
			if !ok {
				t.Fatalf("stdout closed early, got %d lines, expected %d", len(lines), expectedCount)
			}
			lines = append(lines, line)
		case <-timeout:
			t.Fatalf("timed out waiting for stdout lines; got %d expected %d", len(lines), expectedCount)
		}
	}
	return lines
}

// LoadExpectedHecData loads and returns fixture data from the provided path.
func LoadExpectedHecData(t *testing.T, path string) []byte {
	t.Helper()

	data, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		t.Fatalf("failed to read expected data %s: %v", path, err)
	}
	return data
}
