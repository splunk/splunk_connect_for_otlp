// Copyright Splunk Inc. 2025
// SPDX-License-Identifier: Apache-2.0

package testutils

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"go.opentelemetry.io/collector/pdata/plog"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/pdata/ptrace"
	"gopkg.in/yaml.v3"
)

const (
	defaultTimeout         = 5 * time.Second
	DefaultSourceTypeLabel = "com.splunk.sourcetype"
	DefaultSourceLabel     = "com.splunk.source"
	DefaultIndexLabel      = "com.splunk.index"
	DefaultNameLabel       = "otel.log.name"
)

// TelemetryType represents supported telemetry signals.
type TelemetryType string

const (
	TelemetryTypeMetrics TelemetryType = "metrics"
	TelemetryTypeTraces  TelemetryType = "traces"
	TelemetryTypeLogs    TelemetryType = "logs"
)

type IntegrationTestsConfig struct {
	Host           string `yaml:"HOST"`
	User           string `yaml:"USER"`
	Password       string `yaml:"PASSWORD"`
	UIPort         string `yaml:"UI_PORT"`
	HecPort        string `yaml:"HEC_PORT"`
	ManagementPort string `yaml:"MANAGEMENT_PORT"`
	EventIndex     string `yaml:"EVENT_INDEX"`
	MetricIndex    string `yaml:"METRIC_INDEX"`
	TraceIndex     string `yaml:"TRACE_INDEX"`
	HecToken       string `yaml:"HEC_TOKEN"`
	SplunkImage    string `yaml:"SPLUNK_IMAGE"`
}

func GetConfigVariable(configPath, key string) (string, error) {
	// Read YAML file
	fileData, err := os.ReadFile(configPath)
	if err != nil {
		return "", fmt.Errorf("error reading file: %v", err)
	}

	var config IntegrationTestsConfig
	err = yaml.Unmarshal(fileData, &config)
	if err != nil {
		return "", fmt.Errorf("error decoding YAML: %v", err)
	}

	switch key {
	case "EVENT_INDEX":
		return config.EventIndex, nil
	case "METRIC_INDEX":
		return config.MetricIndex, nil
	case "TRACE_INDEX":
		return config.TraceIndex, nil
	default:
		fmt.Println("invalid field")
		return "None", fmt.Errorf("invalid field %v", key)
	}
}

func LoadLogsFromFile(tb testing.TB, path string) plog.Logs {
	tb.Helper()

	data, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		tb.Fatalf("failed to read logs fixture: %v", err)
	}
	unmarshaler := plog.JSONUnmarshaler{}
	logs, err := unmarshaler.UnmarshalLogs(data)
	if err != nil {
		tb.Fatalf("failed to unmarshal logs fixture: %v", err)
	}
	return logs
}

func LoadMetricsFromFile(tb testing.TB, path string) pmetric.Metrics {
	tb.Helper()

	data, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		tb.Fatalf("failed to read metrics fixture: %v", err)
	}
	unmarshaler := pmetric.JSONUnmarshaler{}
	metrics, err := unmarshaler.UnmarshalMetrics(data)
	if err != nil {
		tb.Fatalf("failed to unmarshal metrics fixture: %v", err)
	}
	return metrics
}

func LoadTracesFromFile(tb testing.TB, path string) ptrace.Traces {
	tb.Helper()

	data, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		tb.Fatalf("failed to read traces fixture: %v", err)
	}
	unmarshaler := ptrace.JSONUnmarshaler{}
	traces, err := unmarshaler.UnmarshalTraces(data)
	if err != nil {
		tb.Fatalf("failed to unmarshal traces fixture: %v", err)
	}
	return traces
}

// WriteToStdin pipes the provided content into os.Stdin and returns a restore function.
func WriteToStdin(t *testing.T, content string) func() {
	t.Helper()

	r, w, err := os.Pipe()
	if err != nil {
		t.Fatalf("failed to create stdin pipe: %v", err)
	}

	if _, err = io.Copy(w, strings.NewReader(content)); err != nil {
		t.Fatalf("failed to write stdin content: %v", err)
	}
	if err = w.Close(); err != nil {
		t.Fatalf("failed to close stdin writer: %v", err)
	}

	original := os.Stdin
	os.Stdin = r

	return func() {
		os.Stdin = original
		_ = r.Close()
	}
}

// CaptureStdout captures all stdout output generated by fn and returns it as a string.
func CaptureStdout(t *testing.T, fn func()) string {
	t.Helper()

	original := os.Stdout
	r, w, err := os.Pipe()
	if err != nil {
		t.Fatalf("failed to create stdout pipe: %v", err)
	}
	os.Stdout = w

	outputCh := make(chan string, 1)
	go func() {
		var buf bytes.Buffer
		_, _ = io.Copy(&buf, r)
		_ = r.Close()
		outputCh <- buf.String()
	}()

	fn()

	// TODO: Find a way to synchronize without sleep.
	time.Sleep(1 * time.Second)

	_ = w.Close()
	os.Stdout = original

	return <-outputCh
}

// CaptureStdoutLines returns a channel streaming stdout lines and a restore function.
func CaptureStdoutLines(t *testing.T) (<-chan string, func()) {
	t.Helper()

	original := os.Stdout
	r, w, err := os.Pipe()
	if err != nil {
		t.Fatalf("failed to create stdout pipe: %v", err)
	}
	os.Stdout = w

	lines := make(chan string, 50)
	go func() {
		scanner := bufio.NewScanner(r)
		buf := make([]byte, 0, 64*1024)
		scanner.Buffer(buf, 10*1024*1024)
		for scanner.Scan() {
			lines <- scanner.Text()
		}
		close(lines)
		_ = r.Close()
	}()

	return lines, func() {
		os.Stdout = original
		_ = w.Close()
	}
}

func GetFreePort(t *testing.T) int {
	t.Helper()

	l, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("failed to listen on ephemeral port: %v", err)
	}
	defer func() {
		err = l.Close()
		if err != nil {
			t.Fatalf("failed to close ephemeral port: %v", err)
		}
	}()
	return l.Addr().(*net.TCPAddr).Port
}

// PostOTLP sends the provided data to the endpoint, retrying until success or timeout.
func PostOTLP(t *testing.T, port int, path string, body []byte) {
	t.Helper()

	url := fmt.Sprintf("http://127.0.0.1:%d%s", port, path)
	deadline := time.Now().Add(defaultTimeout)

	lastRespCode := 0
	for {
		resp, err := http.Post(url, "application/json", bytes.NewReader(body))
		if err == nil {
			lastRespCode = resp.StatusCode
			_ = resp.Body.Close()
			if resp.StatusCode == http.StatusOK {
				return
			}
		}

		if time.Now().After(deadline) {
			t.Fatalf("failed to POST %s, response code: %v", path, lastRespCode)
		}
		time.Sleep(100 * time.Millisecond)
	}
}

// CollectLines reads expectedCount lines from the provided channel or fails on timeout.
// Note: There's the possibility that more lines were sent to stdout than expected,
// so the caller must check returned data contents.
func CollectLines(t *testing.T, ch <-chan string, expectedCount int) []string {
	t.Helper()

	var lines []string
	timeout := time.After(defaultTimeout)
	for len(lines) < expectedCount {
		select {
		case line, ok := <-ch:
			if !ok {
				t.Fatalf("stdout closed early, got %d lines, expected %d", len(lines), expectedCount)
			}
			lines = append(lines, line)
		case <-timeout:
			t.Fatalf("timed out waiting for stdout lines; got %d expected %d", len(lines), expectedCount)
		}
	}
	return lines
}

func LoadExpectedHecData(t *testing.T, path string) []byte {
	t.Helper()

	data, err := os.ReadFile(filepath.Clean(path))
	if err != nil {
		t.Fatalf("failed to read expected data %s: %v", path, err)
	}
	return data
}
